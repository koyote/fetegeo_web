#! /usr/bin/env python3

# Copyright (C) 2008 Laurence Tratt http://tratt.net/laurie/
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.


import getopt
import httplib2
import json
import sys
import textwrap
from urllib.parse import urlencode, quote


_VERSION = "0.3"

_DEFAULT_HOST = "127.0.0.1"
_DEFAULT_PORT = 8000
_DEFAULT_LANG = "EN"  # English

_Q_GEO = 0
_Q_CTRY = 1

_SHORT_USAGE_MSG = ("Usage:\n"
                    "  * fetegeoc [-l <lang>] [-s <host>] [-p <port>] country <query string>\n"
                    "  * fetegeoc [-a] [--sa] [-c <country>] [-s <host>] [-p <port>] [-l <lang>]\n"
                    "    geo <query string>\n"
    )

_LONG_USAGE_MSG = _SHORT_USAGE_MSG + ("\n"
                                      "  -a   If -c is specified, find all matches, not just those in the host\n"
                                      "       country.\n"
                                      "\n"
                                      "  -c   Bias the search to the specified country (specified as an ISO2 or ISO3\n"
                                      "       code).\n"
                                      "\n"
                                      "  -l   Specify the preferred language(s) for results to be returned in.\n"
                                      "       Multiple -l options can be specified; they will be treated in descending\n"
                                      "       order of preference.\n"
                                      "\n"
                                      "  --sa If enabled it will print out the whole area as opposed to only the centroid.\n"
    )


class Fetegeoc:
    def __init__(self):
        self._parse_args()

        self._conn = httplib2.Http('.cache')

        if self._q_type == _Q_GEO:
            self._q_geo()
        elif self._q_type == _Q_CTRY:
            self._q_ctry()


    def _parse_args(self):
        try:
            opts, args = getopt.getopt(sys.argv[1:], 'ac:dhl:s:p:', ["show-area", "sa"])
        except getopt.error as e:
            self._usage(str(e), code=1)

        self._find_all = False
        self._country = None
        self._allow_dangling = False
        self._show_area = False
        self._host = _DEFAULT_HOST
        self._port = _DEFAULT_PORT
        self._langs = []
        for opt, arg in opts:
            if opt == "-a":
                self._find_all = True
            elif opt == "-c":
                if self._country is not None:
                    self._usage("Only one -c argument can be specified.")
                self._country = arg
            elif opt == "-d":
                self._allow_dangling = True
            elif opt in ("--sa", "--show-area"):
                self._show_area = True
            elif opt == "-h":
                self._usage(long_help=True)
            elif opt == "-v":
                print(_VERSION)
                sys.exit(0)
            elif opt == "-l":
                self._langs.append(arg)
            elif opt == "-s":
                self._host = arg
            elif opt == "-p":
                try:
                    self._port = int(arg)
                except ValueError:
                    self._usage("Invalid port number '{0}'.".format(arg))

        if self._find_all and self._country is None:
            self._usage("-a makes no sense without -c.")

        if len(self._langs) == 0:
            self._langs.append(_DEFAULT_LANG)

        if len(args) < 2:
            self._usage("Not enough arguments.")
        self._q_str = " ".join(args[1:])

        if args[0] == "geo":
            self._q_type = _Q_GEO
        elif args[0] == "country":
            self._q_type = _Q_CTRY
        else:
            self._usage("Unknown query type '{0}'.".format(args[0]))


    def _usage(self, error_msg="", code=0, long_help=False):
        if error_msg != "":
            sys.stderr.write("Error: {0}\n".format(error_msg))

        if long_help:
            sys.stderr.write(_LONG_USAGE_MSG)
        else:
            sys.stderr.write(_SHORT_USAGE_MSG)
        sys.exit(code)
    
    
    def _pp_geo(self, data):
        self._handle_error(data)
        
        i = 0
        for result in data:
            print("Match #{}".format(i))
            self._print_wrap("{0}: {1}\n".format("OSM ID", result["osm_id"]))
            self._print_wrap("{0}: {1}\n".format("Location Type", result["location"][0]["type"]))
            self._print_wrap("{0}: {1}\n".format("Location Coordinates", result["location"][1]["coordinates"]))
            self._print_wrap("{0}: {1}\n".format("Pretty Print", result["pp"]))
            population = result["population"]
            if population:
                self._print_wrap("{0}: {1}".format("Population", population))
            i += 1
            
            
    def _pp_ctry(self, data):
        self._handle_error(data)
        print("Match:")
        self._print_wrap("{0}: {1}\n".format("Query", data["query"]))
        self._print_wrap("{0}: {1}\n".format("Name", data["result"]))
        lang = data["lang"]
        if lang:
            self._print_wrap("{0}: {1}\n".format("Language", lang))
  
            
    def _print_wrap(self, text):
        print(textwrap.fill(text, initial_indent=' ', subsequent_indent='     '))
        
    
    def _handle_error(self, data):
        if 'error' in data:
            sys.stderr.write("No match found for {}.\n".format(data["query"]))
            sys.exit(1)
        
        
    def _handle_status(self, status):
        if status != 200:
            if status == 404:
                sys.stderr.write("404. Check your config host name and port.\n")
                sys.exit(1)
            elif status == 500:
                sys.stderr.write("Server error. Please try again later.\n")
                sys.exit(1)
            sys.stderr.write("Unknown error\n")
            sys.exit(1) 
        
    def _q_geo(self):
        fa_txt = str(self._find_all).lower()
        ad_txt = str(self._allow_dangling).lower()
        sa_txt = str(self._show_area).lower()

        # if self._country is not None:
        #    country = "<country>{0}</country>\n".format(self._country)
        
        options = dict(find_all=fa_txt, dangling=ad_txt, langs=self._langs)
        url = 'http://{host}:{port}/api/geo/{query}.json'.format(host=self._host, port=self._port, query=quote(self._q_str))
        response, content = self._conn.request(url, 'POST', urlencode(options), {'Content-type': 'application/x-www-form-urlencoded'})

        self._handle_status(response.status)
        
        data = json.loads(content.decode('utf-8'))
        self._pp_geo(data)
        

    def _q_ctry(self):
        options = dict(langs=self._langs)
        url = 'http://{host}:{port}/api/ctry/{query}.json'.format(host=self._host, port=self._port, query=quote(self._q_str))
        response, content = self._conn.request(url, 'POST', urlencode(options), {'Content-type': 'application/x-www-form-urlencoded'})
            
        self._handle_status(response.status)
        data = json.loads(content.decode('utf-8'))
        self._pp_ctry(data)


if __name__ == "__main__":
    Fetegeoc()
